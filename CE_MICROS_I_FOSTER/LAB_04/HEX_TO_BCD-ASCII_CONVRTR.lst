E:\MICROS_1\LAB_04\HEX_TO_BCD-ASCII_CONVRTR.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Tue Nov 11 16:15:10 2008

    1:                                      ;*************************************************************
    2:                                      ;Jacob S. Howarth
    3:                                      ;Microcomputers I - Lab 4
    4:                                      ;CE 320, Fall 2008
    5:                                      ;Prof. Foster
    6:                                      ;
    7:                                      ;Description: This program will convert a 2-byte hexadecimal
    8:                                      ;             value to a 3-byte BCD value and will also convert
    9:                                      ;             a 3-byte hexadecimal value to ASCII without 
   10:                                      ;             leading zeros.
   11:                                      ;*************************************************************
   12:                                      
   13:                                      
   14:                                      ;Define constants
   15:          =00001000                                   ORG $1000
   16:     1000 3000                        HEX_VALUE_ADD   DC.W $3000 ;A constant value containing the address of the 
   17:                                                                 ;hexadecimal number to be converted.
   18:     1002 3002                        BCD_ADDRESS     DC.W $3002 ;A constant value containing the address of where the
   19:                                                                 ;BCD value will be stored.
   20:          =00000030                   ASCII_OFFSET    EQU     $30     ;Value used to convert a BCD value to ASCII
   21:                                      
   22:                                      ;Define program input data
   23:          =00003000                                   ORG $3000
   24:     3000 0080                                        DC.W $0080 ;The hexadecimal value to be converted.
   25:          =00003002                                   ORG $3002
   26:     3002 00 00 00 00 00 00                           DC.B $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00 ;Clear the 
           3008 00 00 00 00 00 00 
           300E 00 00 00 
   27:                                                                                                        ;address line being used.             
   28:                                              
   29:                                      ;Hexadecimal to BCD converter program beginning:
   30:                                      
   31:          =00002000                                   ORG $2000
   32:     2000 FC 1002                [03]                 LDD BCD_ADDRESS
   33:     2003 C3 0005                [02]                 ADDD #5         ;Since the maximum number to be converted is 65535, when
   34:                                                                      ;the division begins, there will be five bytes used to store
   35:                                                                      ;each digit so the address is incremented by 5 since during the
   36:                                                                      ;first division, the least significant digit is returned. This is
   37:                                                                      ;so the number displays correctly from left to right.
   38:     2006 B7 46                  [01]                 TFR D,Y
   39:     2008 FE 1000                [03]                 LDX HEX_VALUE_ADD
   40:     200B EC 00                  [03]                 LDD 0,X         ;Load D with the hex value being converted
   41:     200D 27 0F                  [03] LOOP1           BEQ DONE1
   42:     200F CE 000A                [02]                 LDX #10         ;Load X with $0A since the formula fo IDIV is D/X
   43:     2012 1810                   [0C]                 IDIV
   44:     2014 6B 40                  [02]                 STAB 0,Y        ;Store the least significant digit into the first position
   45:     2016 B7 54                  [01]                 TFR X,D         ;Since X stores the quotient after IDIV instruction, D is reset to the new quotient.
   46:     2018 03                     [01]                 DEY             ;Decrementing Y moves it to the left in the memory map.
   47:     2019 8E 0000                [02]                 CPX #0          ;Repeat until the quotient X is zero.
   48:     201C 20 EF                  [03]                 BRA LOOP1
   49:     201E CD 3007                [02] DONE1           LDY #$3007      ;Load Y with the address of the least significant digit.
   50:     2021 65 5F                  [03]                 ROL -1,Y        ;Rotate left four times to get rid of the leading zero in
   51:     2023 65 5F                  [03]                 ROL -1,Y        ;position pointed to by Y minus 1.
   52:     2025 65 5F                  [03]                 ROL -1,Y
   53:     2027 65 5F                  [03]                 ROL -1,Y
   54:     2029 A6 5F                  [03]                 LDAA -1,Y       ;Add the value in Y - 1 to the value pointed to by Y and store the 
   55:     202B AB 40                  [03]                 ADDA 0,Y        ;value in the address contained in Y.
   56:     202D 6A 40                  [02]                 STAA 0,Y
   57:     202F 03                     [01]                 DEY             ;Decrement the Y pointer
   58:     2030 180A 5F 40             [05]                 MOVB -1,Y,0,Y   ;Shift each of the succeeding digits to the right.
   59:     2034 180A 5E 5F             [05]                 MOVB -2,Y,-1,Y
   60:     2038 180A 5D 5E             [05]                 MOVB -3,Y,-2,Y
   61:     203C E6 5F                  [03]                 LDAB -1,Y       ;Check to the left of the digit succeeding the proceeding digit, if $00 then end program.
   62:     203E 27 21                  [03] LOOP2           BEQ DONE2
   63:     2040 66 5F                  [03]                 ROR -1,Y        ;If the digit succeeding the proceeding digit is not $00, then rotate that digit right.
   64:     2042 66 5F                  [03]                 ROR -1,Y
   65:     2044 66 5F                  [03]                 ROR -1,Y
   66:     2046 66 5F                  [03]                 ROR -1,Y
   67:     2048 66 5F                  [03]                 ROR -1,Y
   68:     204A A6 40                  [03]                 LDAA 0,Y        ;Add the rotated digit to the position before the position Y is currently pointing.
   69:     204C AB 5F                  [03]                 ADDA -1,Y
   70:     204E 6A 40                  [02]                 STAA 0,Y
   71:     2050 03                     [01]                 DEY             ;Decrement the Y pointer and proceed to shift all succeeding bytes, if
   72:                                                                      ;any to the right
   73:     2051 180A 5F 40             [05]                 MOVB -1,Y,0,Y
   74:     2055 180A 5E 5F             [05]                 MOVB -2,Y,-1,Y
   75:     2059 180A 5D 5E             [05]                 MOVB -3,Y,-2,Y
   76:     205D E6 5E                  [03]                 LDAB -2,Y       ;Check the digit succeeding the most significant digit, if $00 end program, if not repeat right rotates.
   77:     205F 20 DD                  [03]                 BRA LOOP2
   78:     2061 69 5F                  [02] DONE2           CLR -1,Y
   79:                                      
   80:                                      
   81:                                      ;Hexadecimal to ASCII program beginning:
   82:                                      
   83:                                      
   84:     2063 FC 1002                [03]                 LDD BCD_ADDRESS ;Load the address of where the BCD value will be stored.
   85:     2066 C3 000A                [02]                 ADDD #10        ;Add ten to the BCD address to offset it from the BCD value
   86:                                                                      ;stored from the above program
   87:     2069 B7 46                  [01]                 TFR D,Y
   88:     206B FE 1000                [03]                 LDX HEX_VALUE_ADD ;Load the hexadecimal value to be converted
   89:     206E EC 00                  [03]                 LDD 0,X
   90:     2070 27 39                  [03]                 BEQ ASCII_ZERO    ;If the hex value is zero, skip the loop
   91:     2072 27 11                  [03] LOOP3           BEQ DONE3         ;The above loop is the same as in the above program
   92:     2074 CE 000A                [02]                 LDX #10           ;the only thing different is the adding of the
   93:     2077 1810                   [0C]                 IDIV              ;ASCII offset to each BCD digit.|
   94:     2079 CB 30                  [01]                 ADDB #ASCII_OFFSET;<------------------------------|
   95:     207B 6B 40                  [02]                 STAB 0,Y
   96:     207D B7 54                  [01]                 TFR X,D
   97:     207F 03                     [01]                 DEY
   98:     2080 8E 0000                [02]                 CPX #0
   99:     2083 20 ED                  [03]                 BRA LOOP3
  100:     2085 FE 1002                [03] DONE3           LDX BCD_ADDRESS   ;When complete append the null string to the end.
  101:     2088 1808 0B 00             [04]                 MOVB #$00,$0B,X
  102:     208C B7 65                  [01]                 TFR Y,X
  103:     208E CD 3008                [02] SHIFT           LDY #$3008        ;Shift the bytes until there are no leading zero's in the
  104:     2091 A6 40                  [03]                 LDAA 0,Y          ;ASCII string by checking the $3008 address.
  105:     2093 26 22                  [03]                 BNE END_OF_PROGRAM
  106:     2095 180A 41 40             [05]                 MOVB 1,Y,0,Y      ;Perform the shift.
  107:     2099 180A 42 41             [05]                 MOVB 2,Y,1,Y
  108:     209D 180A 43 42             [05]                 MOVB 3,Y,2,Y
  109:     20A1 180A 44 43             [05]                 MOVB 4,Y,3,Y
  110:     20A5 180A 45 44             [05]                 MOVB 5,Y,4,Y    
  111:     20A9 20 E3                  [03] SKIP            BRA SHIFT
  112:     20AB C3 0030                [02] ASCII_ZERO      ADDD #ASCII_OFFSET ;If the hex value is zero, add the ASCII offset to zero
  113:     20AE 6B 40                  [02]                 STAB 0,Y
  114:     20B0 FE 1002                [03]                 LDX BCD_ADDRESS   ;Store in position pointed to by Y and append the null string.
  115:     20B3 1808 0B 00             [04]                 MOVB #$00,$0B,X
  116:     20B7 3F                     [09] END_OF_PROGRAM  SWI ;End program
  117:                                      
  118:                                                      
  119:                                                      

Symbols:
ascii_offset                    *00000030
ascii_zero                      *000020ab
bcd_address                     *00001002
done1                           *0000201e
done2                           *00002061
done3                           *00002085
end_of_program                  *000020b7
hex_value_add                   *00001000
loop1                           *0000200d
loop2                           *0000203e
loop3                           *00002072
shift                           *0000208e
skip                             000020a9

